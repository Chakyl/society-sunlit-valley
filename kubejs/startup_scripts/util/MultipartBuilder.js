/**
 * MultipartBuilder.js
 * 
 * Author: Devon
 * Comments generated by ChatGPT, Revised by Devon
 */

console.info("[SOCIETY] Loaded MultipartBuilder");

/**
 * MultipartBuilder(basePath)
 * 
 * Creates a builder instance for a specific base model path. Supports chaining.
 *
 * Example usage:
 *
 *   MultipartBuilder("society:block/my_machine")
 *     .particle()
 *     .doneMark()
 *     .add(
 *       { when: { active: true }, apply: { model: "{base}_on" } },
 *       { when: { active: false }, apply: { model: "{base}_off" } }
 *     )
 *     .build();
 */
function MultipartBuilder(basePath) {
    var entries = [];

    return {
        /**
         * Adds one or more multipart entries.
         *
         * Supports:
         *   add(entry)
         *   add(entry1, entry2, ...)
         *   add([entry1, entry2, ...])
         */
        add: function () {
            for (var i = 0; i < arguments.length; i++) {
                var item = arguments[i];

                if (Array.isArray(item)) {
                    for (var j = 0; j < item.length; j++) {
                        entries.push(item[j]);
                    }
                } else {
                    entries.push(item);
                }
            }
            return this;
        },

        /**
         * Adds a {base}_particle model.
         */
        particle: function () {
            return this.add({ apply: { model: "{base}_particle" } });
        },

        /**
         * Adds a default 'mature' done marker.
         */
        doneMark: function () {
            return this.add({
                when: { mature: true },
                apply: { model: "society:block/machine_done" }
            });
        },

        /**
         * Adds an error state.
         *
         * @param {Object} [check={ valid: false }] - Custom condition for error appearance.
         */
        error: function (check) {
            if (check === undefined) check = { valid: false };
            return this.add({
                when: check,
                apply: { model: "society:block/error" }
            });
        },

        /**
         * Adds a complex entry with an optional model override and variadic modifiers.
         *
         * Overloads:
         *   complex()
         *   complex(mod1, mod2, ...)
         *   complex("model:name")
         *   complex("model:name", mod1, mod2, ...)
         */
        complex: function () {
            var model = "{base}";
            var modifierList = [];

            if (arguments.length > 0) {
                if (typeof arguments[0] === "string") {
                    if (arguments[0]) model = arguments[0];
                    modifierList = Array.prototype.slice.call(arguments, 1);
                } else {
                    modifierList = Array.prototype.slice.call(arguments);
                }
            }

            return this.add({
                apply: { model: model, uvlock: false },
                modifiers: modifierList
            });
        },

        /**
         * Generates final multipart JSON.
         */
        build: function () {
            var result = [];

            function clone(obj) {
                var out = {};
                for (var key in obj) out[key] = obj[key];
                return out;
            }

            function resolveApply(applyObj) {
                var out = {};
                for (var key in applyObj) {
                    var val = applyObj[key];
                    out[key] = typeof val === "string" ? val.replace("{base}", basePath) : val;
                }
                return out;
            }

            function baseEntry(entry) {
                var out = {};
                if (entry.when) out.when = clone(entry.when);
                out.apply = resolveApply(entry.apply);
                return out;
            }

            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i];

                var expanded = [entry];
                if (entry.modifiers && entry.modifiers.length > 0) {
                    var sortedMods = entry.modifiers.slice();
                    sortedMods.sort(function (a, b) {
                        return (a.priority || 0) - (b.priority || 0);
                    });

                    for (var j = 0; j < sortedMods.length; j++) {
                        var modifier = sortedMods[j];
                        var next = [];
                        for (var k = 0; k < expanded.length; k++) {
                            var result = modifier.expand(expanded[k]);
                            for (var m = 0; m < result.length; m++) {
                                next.push(result[m]);
                            }
                        }
                        expanded = next;
                    }
                }

                for (var e of expanded) {
                    result.push(baseEntry(e));
                }
            }

            return { multipart: result };
        }
    };
}

/**
 * MultipartModifiers
 *
 * A collection of reusable entry modifiers for directional, upgrade, and state expansion.
 */
const MultipartModifiers = {};

/**
 * Internal helper: Deep merge an entry with optional model_suffix support.
 */
MultipartModifiers.__mergeEntries = function (base, overrides) {
    function deepClone(obj) {
        var out = {};
        for (var key in obj) {
            var val = obj[key];
            if (val && typeof val === "object") {
                out[key] = deepClone(val);
            } else {
                out[key] = val;
            }
        }
        return out;
    }

    function deepMerge(target, source) {
        var out = deepClone(target);
        for (var key in source) {
            var sVal = source[key];
            var tVal = out[key];
            if (
                sVal &&
                typeof sVal === "object" &&
                tVal &&
                typeof tVal === "object"
            ) {
                out[key] = deepMerge(tVal, sVal);
            } else {
                out[key] = sVal;
            }
        }
        return out;
    }

    var merged = {};

    merged.when = deepMerge(base.when || {}, overrides.when || {});

    var baseApply = base.apply || {};
    var overrideApply = overrides.apply || {};

    var resultApply = deepMerge(baseApply, overrideApply);

    if (
        overrideApply.model_suffix !== undefined &&
        overrideApply.model === undefined &&
        baseApply.model !== undefined
    ) {
        resultApply.model = baseApply.model + overrideApply.model_suffix;
    }

    if ("model_suffix" in resultApply) {
        delete resultApply.model_suffix;
    }

    merged.apply = resultApply;

    return merged;
};

/**
 * Expands a single entry into machine states:
 * - off (working: false, mature: false)
 * - working (working: true, mature: false)
 * - done (working: false, mature: true)
 * Uses model suffixes and respects null to skip states.
 */
MultipartModifiers.machineStateful = function (off_suffix, working_suffix, done_suffix) {
    if (off_suffix === undefined) off_suffix = "_off";
    if (working_suffix === undefined) working_suffix = "";
    if (done_suffix === undefined) done_suffix = "_done";

    var mod = {
        expand: function (entry) {
            var results = [];

            if (off_suffix !== null)
                results.push(MultipartModifiers.__mergeEntries(entry, {
                    when: { working: false, mature: false },
                    apply: { model_suffix: off_suffix }
                }));

            if (working_suffix !== null)
                results.push(MultipartModifiers.__mergeEntries(entry, {
                    when: { working: true, mature: false },
                    apply: { model_suffix: working_suffix }
                }));

            if (done_suffix !== null)
                results.push(MultipartModifiers.__mergeEntries(entry, {
                    when: { working: false, mature: true },
                    apply: { model_suffix: done_suffix }
                }));

            return results;
        },
        priority: 10
    };

    return mod;
};

/**
 * Expands an entry into base and upgraded variants.
 * Adds upgraded: false and upgraded: true conditions and model suffixes.
 */
MultipartModifiers.upgradable = function (base_suffix, upgraded_suffix) {
    if (base_suffix === undefined) base_suffix = "";
    if (upgraded_suffix === undefined) upgraded_suffix = "_upgraded";

    var mod = {
        expand: function (entry) {
            return [
                MultipartModifiers.__mergeEntries(entry, {
                    when: { upgraded: false },
                    apply: { model_suffix: base_suffix }
                }),
                MultipartModifiers.__mergeEntries(entry, {
                    when: { upgraded: true },
                    apply: { model_suffix: upgraded_suffix }
                })
            ];
        },
        priority: 20
    };

    return mod;
};

/**
 * Expands an entry across cardinal directions with matching Y rotations.
 * Adds facing: north/east/south/west and y: 0/90/180/-90 to each variant.
 */
MultipartModifiers.directional = function () {
    var mod = {
        expand: function (entry) {
            var directions = [
                { facing: "north", y: 0 },
                { facing: "east", y: 90 },
                { facing: "south", y: 180 },
                { facing: "west", y: -90 }
            ];

            var result = [];

            for (var i = 0; i < directions.length; i++) {
                var dir = directions[i];

                result.push(
                    MultipartModifiers.__mergeEntries(entry, {
                        when: { facing: dir.facing },
                        apply: { y: dir.y }
                    })
                );
            }

            return result;
        },
        priority: 99
    };

    return mod;
};